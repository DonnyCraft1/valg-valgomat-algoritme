// Do not edit this file. It's a copy of the algorithm from 2017, with typeinfo stripped.
module.exports = {calculateResult};

function calculateResult(politicalParties, userAnswers) {
  const totalStatementCount = politicalParties[0].answers.length;
  const currentUserAnswersCount = userAnswers.length;

  // Calculate result by comparing user's own answers with those provided by the political parties
  const resultList = createResultList(userAnswers, politicalParties);

  // If user has yet to answer all statements, we can simply return the calculated result as is
  if (totalStatementCount !== currentUserAnswersCount) {
    return resultList;
  }

  // Likewise, if user has not prioritized any statements, simply return result as is
  const prioritizedStatements = userAnswers.filter(answer => {
    return answer.isPrioritized;
  });
  if (prioritizedStatements.length === 0) {
    return resultList;
  }

  // If user has answered all statements, test if there are more than one leader
  // If not, return result as is
  const leadingPoliticalParties = extractLeadingPoliticalParties(resultList);

  // If there are just one leader, return result as is
  if (leadingPoliticalParties.length === 1) {
    return resultList;
  }

  // Since there are multiple leaders, create a new score list based on
  // prioritized statements and leading political parties only
  const prioritizedLeadingResultList = createResultList(
    prioritizedStatements,
    leadingPoliticalParties
  );

  // Extract leaders from the new score list based on prioritized statements and
  // leading political parties
  const prioritizedLeadingPoliticalParties = extractLeadingPoliticalParties(
    prioritizedLeadingResultList
  );

  // If the new list of leading, prioritized political parties has multiple items,
  // we cannot really determine a winner. Return result as is
  if (prioritizedLeadingPoliticalParties.length > 1) {
    return resultList;
  }

  const winningPoliticalPartyAmongPrioritizedLeaders = [
    ...prioritizedLeadingResultList
  ].sort(byScoreDescending)[0].politicalParty.id;

  return resultList.map(item => {
    if (
      item.politicalParty.id === winningPoliticalPartyAmongPrioritizedLeaders
    ) {
      item.scorePercent += item.scorePercent <= 99 ? 1 : 0.001;
    }
    return item;
  });
}

function createResultList(userAnswers, politicalParties) {
  const answeredStatementIds = userAnswers
    .filter(
      answer =>
        answer.selectedAlternative &&
        answer.selectedAlternative.stance &&
        answer.selectedAlternative.stance !== 0
    )
    .reduce((prev, next) => {
      return prev.concat(next.statementId);
    }, []);

  const questionDistance = 4;

  return politicalParties.map(politicalParty => {
    let maxUserPartyDistance = answeredStatementIds.length * questionDistance;
    let scorePercent = 0;

    const userPartydistance = politicalParty.answers
      .filter(answer => answeredStatementIds.includes(answer.statementId))
      .map(politicalPartyAnswer => {
        const statementId = politicalPartyAnswer.statementId;
        const userObj = userAnswers.find(userAnswer => {
          return userAnswer.statementId === statementId;
        });
        let partyUserDistance = calculateDistance(
          politicalPartyAnswer,
          userObj
        );
        if (
          userObj &&
          userObj.isPrioritized &&
          userObj.isPrioritized === true
        ) {
          partyUserDistance = partyUserDistance * 2;
          maxUserPartyDistance += questionDistance;
        }
        return partyUserDistance;
      })
      .reduce((prev, next) => {
        return prev + next;
      }, 0);

    if (maxUserPartyDistance === 0) {
      scorePercent = 0;
    } else {
      scorePercent =
        (maxUserPartyDistance - userPartydistance) / maxUserPartyDistance;
    }

    return {
      politicalParty,
      scorePercent
    };
  });
}

function byScoreDescending(resultItemA, resultItemB) {
  const scorePercentA = resultItemA.scorePercent;
  const scorePercentB = resultItemB.scorePercent;
  // console.log('by score descending ran, comparing', scorePercentA, scorePercentB)
  return scorePercentB - scorePercentA;
}

function extractLeadingPoliticalParties(result) {
  const leaderScorePercent = getLeaderScorePercent(result);
  return result
    .filter(item => {
      return item.scorePercent === leaderScorePercent;
    })
    .map(item => item.politicalParty);
}

function getLeaderScorePercent(resultList) {
  const sortedScoreList = [...resultList].sort(byScoreDescending);
  const leader = sortedScoreList[0];
  return leader.scorePercent;
}

function calculateDistance(politicalPartyAnswer, userAnswer) {
  if (!userAnswer) {
    return 0;
  }
  return Math.abs(
    politicalPartyAnswer.selectedAlternative.stance -
      userAnswer.selectedAlternative.stance
  );
}
